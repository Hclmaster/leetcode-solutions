## 背景

最近两周在看书，看完了两本书《腾讯传》和《白鹿原》，然后算法分享就延后了。  
这周规划一下自己的时间，尽量合理分配。  

这里分享一下一周前在小密圈分享的一道回文串的题。  
对于算法题，我的建议是自己实现一下。
不然到后面面对大项目或者复杂算法题的时候，你会发现这些基础算法也是需要很多技巧的。  

分享的算法题，一般是英文题，这是由于标准的ACM比赛的题目都是英文题。  


## 题意



告诉你一个大整数，求离这个数最近的回文数（不包含自身）。  

然后有两个提示。

> 
> 当最近的回文数存在多个时，取最小的回文数。  
> 输入的大整数位数不超过18位。  
> 


## 边界

1. 个位数都算回文数  
2. 部分数字的长度和答案的长度可能不同。（10的幂数）  
3. 最近回文数有多个时，取最小的那个。  


## 思路  


1. 拆解：先得到小于该数字的最大回文串和大于该数字的最小回文串。  
2. 转化：拆解1 - 小于该数字的最大回文串等价于小于等于该数字减一的最大回文串。  
3. 贪心：拆解1 - 假设某位为数字'a'有解，则该位为['0','a'-1]的解都不没有'a'更优，故每一位从'9'到'0'迭代。  
4. 同理：对于拆解2，和拆解1相反的做法。  
5. 合并：两个局部最优解和当前数字求差值，差值小的为最优解。  


## 代码

见[github](https://github.com/tiankonguse/leetcode-solutions/tree/master/problemset/find-the-closest-palindrome)

